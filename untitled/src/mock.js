export const qwestions = [
    ['В чем разница между null и undefined?', ' Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS. Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора "!!" является false undefined («неопределенный») представляет собой значение по умолчанию:\n' +
    'переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;\n' +
    'функции, которая ничего не возвращает явно, например, console.log(1);\n' +
    'несуществующего свойства объекта. null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок. При сравнении null и undefined мы получаем true, когда используем оператор "==", и false при использовании оператора "===".'],


    ['Для чего используется оператор "&&"', 'Оператор "&&" (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат'],


    ['Что такое DOM?', 'DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.' +
    ' в печати и вэб-дизайне. Lorem Ipsum является стандартной "рыбой" для текстов на латинице с начала XVI века. '],
    [' Что такое распространение события (Event Propagation)?', 'Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:\n' +
    'Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.\n' +
    'Целевая фаза — это когда событие достигает целевого элемента.\n' +
    'Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.'],


    ['Что такое всплытие события?', '\n' +
    'Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window. ps: У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.'],


    ['Что такое погружение события?', 'Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков. ps: У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения. Если мы кликнем по элементу child, то увидим в консоли следующее: window, document, html, grandparent, parent, child. Это и есть погружение события.'],


    ['В чем разница между методами event.preventDefault() и event.stopPropagation()?', 'Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение).'],


    ['Как узнать об использовании метода event.preventDefault()?', 'Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.'],


    ['12. Что такое цель события или целевой элемент (event.target)?', 'Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.'],

    ['13. Что такое текущая цель события (event.currentTarget)?', 'Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий. ']



        [' Как записать несколько выражений в одну строку?', 'Для этого мы можем использовать оператор "," (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда. '],


    ['Что такое поднятие (Hoisting)?', 'Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.\n' +
    '\n' +
    'Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.\n' +
    '\n' +
    'Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.\n' +
    '\n' +
    'Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).\n' +
    '\n' +
    'Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.\n' +
    '\n' +
    'Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.']




        [' Что такое область видимости (Scope)?', ' Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).\n' +
    '\n' +
    'Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде. Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции. \n' +
    'Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него. Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).'],


    ['20.Что такое замыкание (Closures)?', ' Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание.\n' +
    '\n' +
    'По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.']




        ['23. Для чего используется директива «use strict»?', '«use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах. Нельзя присваивать значения или обращаться к необъявленным переменным, Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи. Нельзя удалить «неудаляемое» свойство объекта. Запрещено дублирование параметров. \n' +
    'Нельзя создавать функции с помощью функции eval. Значением «this» по умолчанию является undefined '],


    ['Какое значение имеет this?', 'Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this. Стрелочные функции не имеют собственного значения this. Они копируют значение this из внешнего лексического окружения.\n '],


    ['25. Что такое прототип объекта?', '\n' +
    'В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. '],


    ['26. Что такое IIFE?', 'IFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})().  Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). '],


    ['27. Для чего используется метод Function.prototype.apply?', 'Apply используется для привязки определенного объекта к значению this вызываемой функции. Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива.'],


    ['28. Для чего используется метод Function.prototype.call?', ' Call используется для привязки определенного объекта к значению this вызываемой функции. Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую.'],


    ['29. В чем разница между методами call и apply?', 'Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую. '],


    ['30. Для чего используется метод Function.prototype.bind?', 'Bind возвращает новую функцию, значением this которой является объект, указанный в качестве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию. '],


    ['31. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?', 'Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.\n' +
    '\n' +
    'Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования. '],


    ['32. Что такое функции высшего порядка (Higher Order Functions)?', 'Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента. '],


    ['33. Почему функции в JS называют объектами первого класса (First-class Objects)?', ' Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.'],


    ['34. Как бы Вы реализовали метод Array.prototype.map?', 'Метод map создает новый массив с результатом вызова указанной функции для каждого элемента массива.'],


    ['35. Как бы Вы реализовали метод Array.prototype.filter?', 'Метод filter создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции. '],


    ['36. Как бы Вы реализовали метод Array.prototype.reduce?', ' Метод reduce применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.'],


    ['37. Что такое объект arguments?', ' Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции. \n' +
    'Запомните: в стрелочных функциях объект arguments не работает.'],


    ['38. Как создать объект, не имеющий прототипа?', ' Это можно сделать с помощью Object.create:'],


    ['39. Почему в представленном коде переменная b становится глобальной при вызове функции? function myFunc(){\n' +
    '    let a = b = 0\n' +
    '}\n' +
    'myFunc()', ' Так происходит, потому что оператор присваивания ("=") имеет правостороннюю ассоциативность, т.е. присваивает значения справа налево. Поэтому код принимает следующий вид: function myFunc(){\n' +
    '    let a = (b = 0)\n' +
    '}\n' +
    'myFunc() Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a». Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения: function myFunc(){\n' +
    '    let a, b\n' +
    '    a = b = 0\n' +
    '}\n' +
    'myFunc()'],


    ['40. Что такое ECMAScript?', ' ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.'],


    ['41. Что нового привнес в JS стандарт ES6 или ECMAScript2015?', 'Стрелочные функции (Arrow Functions).\n' +
    'Классы (Classes).\n' +
    'Шаблонные строки (Template Strings).\n' +
    'Расширенные объектные литералы (Enhanced Object literals).\n' +
    'Деструктуризация (Object Destructuring).\n' +
    'Промисы (Promises).\n' +
    'Генераторы (Generators).\n' +
    'Модули (Modules).\n' +
    'Symbol.\n' +
    'Прокси (Proxies).\n' +
    'Множества (Sets).\n' +
    'Параметры по умолчанию.\n' +
    'Операторы rest и spread.\n' +
    'Блочная область видимости (ключевые слова «let» и «const»). '],


    ['42. В чем разница между ключевыми словами «var», «let» и «const»?', 'Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Это означает, что они доступны из любого места в коде:\n' +
    '\n' +
    'function giveMeX(showX){\n' +
    '    if(showX){\n' +
    '        var x = 5\n' +
    '    }\n' +
    '    return x\n' +
    '}\n' +
    '\n' +
    'console.log(giveMeX(false))\n' +
    'console.log(giveMeX(true))\n' +
    '\n' +
    'Результатом первого console.log будет undefined, второго — 5. Мы имеем доступ к переменной «x» из-за ее всплытия в глобальную область видимости. Код из примера выше интерпретируется следующим образом:\n' +
    '\n' +
    'function giveMeX(showX){\n' +
    '    var x // имеет значение undefined\n' +
    '    if(showX){\n' +
    '        x = 5\n' +
    '    }\n' +
    '    return x\n' +
    '}\n' +
    '\n' +
    'Результатом первого console.log является undefined, поскольку объявленные переменные, которым не присвоено значения, имеют значение undefined по умолчанию.\n' +
    '\n' +
    'Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }):\n' +
    '\n' +
    'function giveMeX(showX){\n' +
    '    if(showX){\n' +
    '        let x = 5\n' +
    '    }\n' +
    '    return x\n' +
    '}\n' +
    '\n' +
    'function giveMeY(showY){\n' +
    '    if(showY){\n' +
    '        let y = 5\n' +
    '    }\n' +
    '    return y\n' +
    '}\n' +
    '\n' +
    'Вызов этих функций с параметром false приведет к ошибке ReferenceError, потому что к переменным «x» и «y» нет доступа снаружи блока и их значения не возвращаются (не всплывают).\n' +
    '\n' +
    'Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную). '],


    ['43. Что такое стрелочные функции (Arrow Functions)?', 'Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:\n' +
    '\n' +
    '// ES5\n' +
    'var getCurrentDate = function(){\n' +
    '    return new Date()\n' +
    '}\n' +
    '\n' +
    '// ES6\n' +
    'const getCurrentDate = () => new Date()\n' +
    '\n' +
    'В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение:\n' +
    '\n' +
    '// ES5\n' +
    'function greet(name){\n' +
    '    return \'Hello \' + name + \'!\' \n' +
    '}\n' +
    '\n' +
    '// ES6\n' +
    'const greet = (name) => `Hello ${name}`\n' +
    'const greet2 = name = > `Hello ${name}`\n' +
    '\n' +
    'Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:\n' +
    '\n' +
    'const getArgs = () => arguments\n' +
    '\n' +
    'const getArgs2 = (...rest) => rest\n' +
    '\n' +
    'У стрелочных функций нет доступа к объекту arguments. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор rest.\n' +
    '\n' +
    'const data = {\n' +
    '    result: 0\n' +
    '    nums: [1,2,3,4,5]\n' +
    '    computeResult(){\n' +
    '        // this ссылается на объект data\n' +
    '        const addAll = () => {\n' +
    '        // стрелочные функции копируют значение this из лексического окружения\n' +
    '        return this.nums.reduce((total, cur) => total + cur, 0)\n' +
    '        }\n' +
    '    this.result = addAll()\n' +
    '    }\n' +
    '} '],


    ['44. Что такое классы (Classes)?', 'Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:\n' +
    '\n' +
    '// ES5\n' +
    'function Person(firstName, lastName, age, address){\n' +
    '    this.firstName = firstName\n' +
    '    this.lastName = lastName\n' +
    '    this.age = age\n' +
    '    this.address = address\n' +
    '}\n' +
    '\n' +
    'Person.self = function(){\n' +
    '    return this\n' +
    '}\n' +
    '\n' +
    'Person.prototype.toString = function(){\n' +
    '    return \'[object Person]\'\n' +
    '}\n' +
    '\n' +
    'Person.prototype.getFullName = function(){\n' +
    '    return this.firstName + \' \' + this.lastName\n' +
    '}\n' +
    '\n' +
    '// ES6\n' +
    'class Person{\n' +
    '    constructor(firstName, lastName, age, address){\n' +
    '        this.firstName = firstName\n' +
    '        this.lastName = lastName\n' +
    '        this.age = age\n' +
    '        this.address = address\n' +
    '    }\n' +
    '\n' +
    '    static self(){\n' +
    '        return this\n' +
    '    }\n' +
    '\n' +
    '    toString(){\n' +
    '        return \'[object Person]\'\n' +
    '    }\n' +
    '\n' +
    '    getFullName(){\n' +
    '        return `${this.firstName} ${this.lastName}`\n' +
    '    }\n' +
    '}\n' +
    '\n' +
    'Переопределение методов и наследование от другого класса:\n' +
    '\n' +
    '// ES5\n' +
    'Employee.prototype = Object.create(Person.prototype)\n' +
    '\n' +
    'function Employee(firstName, lastName, age, address, jobTitle, yearStarted){\n' +
    '    Person.call(this, firstName, lastName, age, address)\n' +
    '    this.jobTitle = jobTitle\n' +
    '    this.yearStarted = yearStarted\n' +
    '}\n' +
    '\n' +
    'Employee.prototype.describe = function(){\n' +
    '    return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}`\n' +
    '}\n' +
    '\n' +
    'Employee.prototype.toString = function(){\n' +
    '    return \'[object Employee]\'\n' +
    '}\n' +
    '\n' +
    '// ES6\n' +
    'class Employee extends Person{ // наследуемся от Person\n' +
    '    constructor(firstName, lastName, age, address, jobTitle, yearStarted){\n' +
    '        super(firstName, lastName, age, address)\n' +
    '        this.jobTitle = jobTitle\n' +
    '        this.yearStarted = yearStarted\n' +
    '    }\n' +
    '\n' +
    '    describe(){\n' +
    '       return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}` \n' +
    '    }\n' +
    '\n' +
    '    toString(){ // переопределяем метод toString класса Person\n' +
    '        return \'[object Employee]\'\n' +
    '    }\n' +
    '}\n '],


    ['46. Что такое деструктуризация объекта (Object Destructuring)?', ' \n' +
    'Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива.'],


    ['47. Что такое модули (Modules)?', 'Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода:\n' +
    '\n' +
    'CommonJS — Nodejs\n' +
    'AMD (AsyncronousModuleDefinition) — Browsers\n' +
    '\n' +
    'Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта.\n '],


    ['48. Что такое объект Set?', 'Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue. '],


    ['49. Что такое функция обратного вызова (Callback Function)?', 'Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события).\n' +
    '\n' +
    'const btnAdd = document.getElementById(\'btnAdd\')\n' +
    '\n' +
    'btnAdd.addEventListener(\'click\', function clickCallback(e)){\n' +
    '    // делаем нечто полезное\n' +
    '}\n' +
    '\n' +
    'В примере мы ждем события «клик» на элементе с идентификатором «btnAdd». По клику вызывается функция clickCallback. Функция обратного вызова добавляет некоторый функционал данным или событию. Методам reduce, filter и map в качестве второго аргумента передается функция обратного вызова. Хорошей аналогией callback является следующая ситуация: Вы звоните кому-то, он не отвечает, Вы оставляете ему сообщение и ждете, когда он перезвонит. Звонок или сообщение — это событие или данные, а callback — это ожидание (предвосхищение) встречного звонка. '],


    ['50. Что такое промисы (Promises)?', 'Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова». У промиса есть четыре состояния:\n' +
    '\n' +
    'Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не завершена.\n' +
    'Выполнено — асинхронная операция выполнена, имеется результат.\n' +
    'Отклонено — асинхронная операция не выполнена, имеется причина.\n' +
    'Завершено — выполнено или отклонено. '],


    ['51. Что такое async/await?', ' Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова. Однако для использования async/await необходимо хорошо знать промисы.'],


    ['52. В чем разница между spread-оператором и rest-оператором?', ' Операторы spread и rest имеют одинаковый синтаксис ("..."). Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров).\n' +
    '\n' +
    'function add(a, b){\n' +
    '    return a + b\n' +
    '}\n' +
    '\n' +
    'const nums = [5, 6]\n' +
    'const sum = add(...nums)\n' +
    'console.log(sum) // 11\n' +
    '\n' +
    'В этом примере мы используем spread при вызове функции add с данными массива nums. Значением переменной «a» будет 5, b = 6, sum = 11.\n' +
    '\n' +
    'function add(...rest){\n' +
    '    return rest.reduce((total, current) => total + current)\n' +
    '}\n' +
    '\n' +
    'console.log(add(1, 2)) // 3\n' +
    'console.log(add(1, 2, 3, 4, 5)) // 15\n' +
    '\n' +
    'Здесь мы вызываем функцию add с любым количеством аргументов. Add возвращает сумму этих аргументов.\n' +
    '\n' +
    'const [first, ...others] = [1, 2, 3, 4, 5]\n' +
    'console.log(first) // 1\n' +
    'console.log(others) // [2, 3, 4, 5]\n' +
    '\n' +
    'В этом примере мы используем rest для помещения любого количества параметров, кроме первого, в массив others.'],


    ['57. Как проверить, является ли значение массивом?', 'Для этого следует использовать метод Array.isArray: '],


    ['59. Как определить наличие свойства в объекте?', ' Первый способ состоит в использовании оператора «in»:, Второй — использовать метод hasOwnProperty: console.log(o.hasOwnProperty(\'prop2\')) '],


    ['60. Что такое AJAX?', 'AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы.\n' +
    '\n' +
    'AJAX использует следующие технологии:\n' +
    'HTML — структура веб-страницы.\n' +
    'CSS — стили веб-страницы.\n' +
    'JavaScript — поведение страницы и работа с DOM.\n' +
    'XMLHttpRequest API — отправка и получение данных с сервера.\n' +
    'PHP, Python, Nodejs — какой-нибудь серверный язык. '],


    [' В чем разница между методами Object.freeze и Object.seal?', 'Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется. '],


    ['63. В чем разница между оператором «in» и методом hasOwnProperty?', ' Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.'],


    [
        '64. Какие приемы работы с асинхронным кодом в JS Вы знаете?', ' Функции обратного вызова (Callbacks).\n' +
    'Промисы (Promises).\n' +
    'Async/await.\n' +
    'Библиотеки вроде async.js, blueprint, q, co.'],


    ['65. В чем разница между обычной функцией и функциональным выражени', 'Допустим, у нас есть следующее:\n' +
    '\n' +
    'hoistedFunc()\n' +
    'notHoistedFunc()\n' +
    '\n' +
    'function hoistedFunc(){\n' +
    '    console.log(\'I am hoisted\')\n' +
    '}\n' +
    '\n' +
    'var notHoistedFunc = function(){\n' +
    '    console.log(\'I will not be hoisted!\')\n' +
    '}\n' +
    '\n' +
    'Вызов notHoistedFunc приведет к ошибке, а вызов hoistedFunc нет, потому что hoistedFunc «всплывает», поднимается в глобальную область видимости, а notHoistedFunc нет.\n '],


    ['66. Как в JS вызвать функцию?', ' В JS существует 4 способа вызвать функцию. Вызов определяет значение this или «владельца» функции. \n' +
    'Вызов в качестве функции. Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window. Вызов в качестве метода. Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением this становится объект этого метода. Вызов в качестве конструктора. Когда функция вызывается с использованием ключевого слова «new», мы называем такую функцию конструктором. При этом создается пустой объект, являющийся значением this. \n' +
    'Вызов с помощью методов apply или call. Мы используем эти методы, когда хотим явно определить значение this или владельца функции:'],


    ['67. Что такое запоминание или мемоизация (Memoization)?', 'Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов. '],


    ['70. Для чего используется ключевое слово «new»?', 'Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).\n Ключевое слово «new» делает 4 вещи:\n' +
    '\n' +
    'Создает пустой объект.\n' +
    'Привязывает к нему значение this.\n' +
    'Функция наследует от functionName.prototype.\n' +
    'Возвращает значение this, если не указано иное. '],


];

